// Generated by IcedCoffeeScript 1.3.3g
(function() {
  var MiniProxy, bouncy, colors, fs, iced, path, __iced_k, __iced_k_noop,
    __slice = [].slice;

  iced = {
    Deferrals: (function() {

      function _Class(_arg) {
        this.continuation = _arg;
        this.count = 1;
        this.ret = null;
      }

      _Class.prototype._fulfill = function() {
        if (!--this.count) return this.continuation(this.ret);
      };

      _Class.prototype.defer = function(defer_params) {
        var _this = this;
        ++this.count;
        return function() {
          var inner_params, _ref;
          inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (defer_params != null) {
            if ((_ref = defer_params.assign_fn) != null) {
              _ref.apply(null, inner_params);
            }
          }
          return _this._fulfill();
        };
      };

      return _Class;

    })(),
    findDeferral: function() {
      return null;
    },
    trampoline: function(_fn) {
      return _fn();
    }
  };
  __iced_k = __iced_k_noop = function() {};

  fs = require('fs');

  path = require('path');

  colors = require('colors');

  bouncy = require('bouncy');

  MiniProxy = (function() {

    function MiniProxy() {}

    MiniProxy.prototype.use = function(path) {
      var _this = this;
      this.routes = {};
      fs.readdir(path, function(err, result) {
        var data, err, filename, host, json, packagePath, port, stats, ___iced_passed_deferral, __iced_deferrals, __iced_k;
        __iced_k = __iced_k_noop;
        ___iced_passed_deferral = iced.findDeferral(arguments);
        if (err) throw err;
        (function(__iced_k) {
          var _i, _len, _ref, _results, _while;
          _ref = result;
          _len = _ref.length;
          _i = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++_i;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(_i < _len)) {
              return _break();
            } else {
              filename = _ref[_i];
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/miniproxy.coffee"
                });
                fs.stat("" + path + "/" + filename, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      err = arguments[0];
                      return stats = arguments[1];
                    };
                  })(),
                  lineno: 16
                }));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  if (stats.isDirectory()) {
                    packagePath = "" + path + "/" + filename + "/package.json";
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "src/miniproxy.coffee"
                      });
                      fs.readFile(packagePath, __iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            err = arguments[0];
                            return data = arguments[1];
                          };
                        })(),
                        lineno: 20
                      }));
                      __iced_deferrals._fulfill();
                    })(function() {
                      var _ref1;
                      if (typeof data !== "undefined" && data !== null) {
                        json = JSON.parse('' + data);
                        if (json.routes != null) {
                          _ref1 = json.routes;
                          for (host in _ref1) {
                            port = _ref1[host];
                            _this.routes[host] = parseInt(port, 10);
                          }
                        }
                      }
                      return __iced_k();
                    });
                  } else {
                    return __iced_k();
                  }
                })(_next);
              });
            }
          };
          _while(__iced_k);
        })(function() {
          var _ref, _results;
          _this.server = bouncy(function(req, res, bounce) {
            var host, index, port;
            index = req.headers.host.indexOf(':');
            if (index !== -1) {
              host = req.headers.host.slice(0, index);
            } else {
              host = req.headers.host;
            }
            port = _this.routes[host];
            if (port != null) {
              return bounce(port);
            } else {
              res.statusCode = 404;
              return res.end('invalid host');
            }
          });
          _this.server.listen(_this.port);
          console.log("proxy from port " + ('' + _this.port).green);
          _ref = _this.routes;
          _results = [];
          for (host in _ref) {
            port = _ref[host];
            _results.push(console.log("  to port " + ("" + port).green + " when using host " + ("" + host).magenta));
          }
          return _results;
        });
      });
      return this;
    };

    MiniProxy.prototype.listen = function(port, host) {
      this.port = port;
      this.host = host;
      return this;
    };

    return MiniProxy;

  })();

  module.exports = new MiniProxy();

}).call(this);
